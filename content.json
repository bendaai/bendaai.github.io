{"pages":[],"posts":[{"title":"Leetcode 1. 两数之和","text":"比较简单的一道题，用字典idx保存 值：位置 题目内容 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 题解class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: idx=dict() for i in range(len(nums)): diff=target-nums[i] if diff in idx: return [idx[diff],i] idx[nums[i]]=i return [-1,-1]","link":"/2020/03/02/Leetcode%201.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"Leetcode 2. 两数相加","text":"考察链表，链表的题都可以设置一个头结点，之后前插入或后插入 题目内容 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 #题解 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: ''' e表示为进位 pre作为返回链表的头结点，方便处理 10进制按位进行加法 注意情况： 一个链表结束，但有1的情况 ''' pre=ListNode(0) p=pre e=0 while l1 and l2: v=l1.val+l2.val+e l1.val,e=v%10,v//10 p.next=l1 p=l1 l1,l2=l1.next,l2.next if l2: p.next=l2 while e==1 and p.next: v=p.next.val+e e,p.next.val=v//10,v%10 p=p.next if e==1: p.next=ListNode(1) return pre.next","link":"/2020/03/02/Leetcode%202.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"title":"Leetcode 3. 无重复字符的最长子串","text":"dp[k]保存以k位置字符为结尾的最长子串长度idx[e]保存e字符上一个出现的位置,如果没出现过，则认为上一个出现位置为-1动态规划方程：dp[k]=min(dp[k-1]+1,k-idx[s[k]]) 题目内容 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例: 示例1:输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2:输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3:输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 题解class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: ''' dp[k]保存以k位置字符为结尾的最长子串长度 idx[e]保存e字符上一个出现的位置,如果没出现过，则认为上一个出现位置为-1 动态规划方程：dp[k]=min(dp[k-1]+1,k-idx[s[k]]) ''' if s=='': return 0 dp=[1 for i in range(len(s))] idx={s[0]:0} for k in range(1,len(s)): dp[k]=min(dp[k-1]+1,k-idx.get(s[k],-1)) idx[s[k]]=k return max(dp) 还可对dp数组进行压缩 class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: ''' 动态规划方程：dp[k]=min(dp[k-1]+1,k-idx[s[k]]) dp[k]只和dp[k-1]有关，所以可以进行数组压缩 ''' if s=='': return 0 ans=1 dp=1 idx={s[0]:0} for k in range(1,len(s)): dp=min(dp+1,k-idx.get(s[k],-1)) ans=max(ans,dp) idx[s[k]]=k return ans","link":"/2020/03/02/Leetcode%203.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"Leetcode 4. 寻找两个有序数组的中位数","text":"把问题统一为寻找中间两个数的问题，用二分查找寻找第k个数 题目内容 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 示例 示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0 2示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 题解class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: ''' 寻找中间两个元素 ''' def find_no_k(nums1,nums2,l1,l2,k): ''' 假设左右数组分别为AB 我们将查找A的min(k/2,len(A)),设为la 和B的k-la 得到A1,a,A2;B1,b,B2; 若a&lt;b,由于a&lt;{b,B2,A2},而除去{b,B2,A2}，两数组剩余不到k, 因此a的位置在k前面，既可以舍弃a,A1 若a==b,答案就是a 若a&gt;b,同理舍弃b,B1 ''' L1,L2=len(nums1)-l1,len(nums2)-l2 if L1&gt;L2:#保证nums1代表的长度短的，方便处理 return find_no_k(nums2,nums1,l2,l1,k) if L1==0: return nums2[l2+k-1] if k==1: return min(nums1[l1],nums2[l2]) la=min(k//2,L1) lb=k-la a,b=nums1[la+l1-1],nums2[lb+l2-1] if a&lt;b: return find_no_k(nums1,nums2,l1+la,l2,k-la) if a&gt;b: return find_no_k(nums1,nums2,l1,l2+lb,k-lb) return a L1,L2=len(nums1),len(nums2) return (find_no_k(nums1,nums2,0,0,(L1+L2)//2+1)+find_no_k(nums1,nums2,0,0,(L1+L2-1)//2+1))/2","link":"/2020/03/02/Leetcode%204.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"title":"UVA 210. Concurrency Simulator","text":"逻辑其实挺清晰的，但是数据坑点很多,怀疑数据中可能有多的空行。 题目链接https://vjudge.net/problem/UVA-210 import sys import queue def _input(): lines=sys.stdin.readlines() for val in lines: x=val.strip() if x!='': yield x c=_input() def func(): n,t1,t2,t3,t4,t5,Q=list(map(int,next(c).split())) code_list=[] for i in range(n): que=queue.deque() while 1: s=next(c).strip() que.append(s) if s=='end': break code_list.append(que) block_que=queue.deque() wait_que=queue.deque() locked=0 var2val={} for i in range(n): wait_que.append(i) while len(wait_que)!=0: k=wait_que.popleft() t=Q while 1: s=code_list[k].popleft() if s=='end': break elif s=='lock': t-=t3 if locked==1: code_list[k].appendleft(s) block_que.append(k) break else: locked=1 elif s=='unlock': t-=t4 locked=0 if len(block_que)&gt;0: wait_que.appendleft(block_que.popleft()) elif '=' in s: t-=t1 var2val[s[0]]=s.split('=')[-1].strip() else: t-=t2 var=s[-1] print(f'{k+1}: {var2val.get(var,0)}') if t&lt;=0: wait_que.append(k) break T=int(next(c)) for i in range(T): if i&gt;0: print() func()","link":"/2020/03/02/UVA%20210.%20Concurrency%20Simulator/"},{"title":"正则表达式入门","text":"下午看了正则表达式必知必会，总结一波 注意，正则匹配机制是匹配到一串字符后，从匹配字符结尾的下一个位置，继续匹配 字符匹配层次单字符: ‘.’：匹配任意字符‘\\‘:转义元字符【’.’在”[]”内可以不进行转义】 多字符和的元字符:[]、’^’ “[abcd]”:abcd中的一个“[a-z]”:a到z中的一个“[^1-9]”:除了1到9，其他字符都可以 重复:”{}”、’+’、’*’、’?’k次重复上一个字符 ‘*’:[0,$\\infty$)‘+’:[1,$\\infty$)‘?’:{0,1}‘{a,b}:[a,b]‘{a}’:{a}‘{a,}:[a,$\\infty$) 以上都为贪婪型，即尽可能多的匹配，加上?变为懒惰型，如’*?’、’+?’、’{n,}?’不过，在线的正则表达式网站，加上?后只有第一个为懒惰，后面仍为贪婪型 特殊字符空白元字符 \\f:换页\\n:换行\\r:回车\\t:制表\\v:垂直制表 字母数字相关 \\d:[0-9]\\D:[^0-9]\\w:[a-zA-Z0-9_]\\W:[^a-zA-Z0-9_]\\s:[\\f\\n\\r\\t\\v]任一空白字符\\S:[^\\f\\n\\r\\t\\v] POSIX字符类 [:blank:]:[\\t ][:cntrl:]:ASCII控制字符，ASCII0-31、ASCII127[:digit:]:[0-9][:print:]:任一个可打印字符[:graph:]:[:print:]不包括空格[:lower:]:[a-z][:upper:]:[A-Z][:punct:]:既不属于:alnum:也不属于[:cntrl:][:space:]:[\\f\\n\\r\\t\\v][:xdigit:]:[a-fA-F0-9] 使用:[[:digit:]]双括号表示 位置匹配 \\b:单词开始或结尾\\B:不匹配单词边界^:字符串开始边界，在[]中代表的是取反$:字符串结束边界(^m):放在开头表示字符串行分隔符作为字符串边界对待\\A:字符串开始，不随(^m)改变行为，但又有些不支持\\Z:字符串结尾，不随(^m)改变行为，但又有些不支持 表达式和替换子表达式:’|’、”()”通过”()”把子串作为一个整体,比如(&nbsp;){2}代表&nbsp;&nbsp;子表达式嵌套：((x)|(y)):(x)或者(y) 回溯引用：前后一致匹配:”\\k”“(x).*\\1” : \\1代表的就是(x)【\\k代表的是第k个子表达式】 表达式在替换中的应用:’$’find:(\\w+[\\w\\.]*@[\\w\\.]+\\.\\w+)【邮箱地址】 replace: &lt;A HREF=&quot;mailto:$1&quot;&gt;$1&lt;/A&gt;【跨模式使用】 替换中大小写转换 \\E:结束\\L或\\U转换\\l:下一个转为小写\\L:\\L到\\E转为小写\\u:下一个转为大写\\U:\\U到\\E转为大写 前后查找查找到的字符串的一部分http://www.forta.com/前向查找”(?=)”–&gt;”.+(?=:)”–&gt;搜索到的是http【后接串匹配】 (?=) 正向前查找(?!) 负向前查找【后接串不匹配的子串】(?&lt;!) 正向后查找(?&lt;!) 负向后查找【前接串不匹配的子串】 嵌入条件: (?(condition)true-regex|false-regex)condition存在的时候，为true-regex否则false-regex，其中|false-regex可以省略 condition:回溯引用条件【根据子表达式来if】&quot;(x).\\*(?(1)x|y)&quot; 如果(x)存在：&quot;(x).\\*x&quot;不存在&quot;(x).\\*y&quot; condition:前后查找条件【根据前后串的情况来进行if】对于5数字和5数子-4数字两种情况【14789-1589、15979】\\d{5}(?(?=-)-\\d{4})","link":"/2020/03/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"Leetcode 5. 最长回文子串","text":"马拉车算法，根据回文串的对称性质的动态规划方法，O(n)复杂度 题目内容 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 #示例 示例 1：输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2：输入: “cbbd”输出: “bb” 题解class Solution: def longestPalindrome(self, s: str) -&gt; str: ''' 马拉车算法： 对s进行#填充,得到s[0]#s[1]#s[2]...#s[-1]的形式， 这样每个位置的最大回文串都是奇数长度 dp[i]保存的是 i位置的最大回文串长度//2 过程中保存回文串可以达到的最远位置的状态 M_idx为该回文串的中心位置坐标，M为最远位置坐标.M=M_idx+dp[M_idx] 求dp[i]时，若i&lt;=M,我们可以得到i关于M_idx的对称点,2*M_idx-i,且由于对称性， 若dp[2*M_idx-i]&lt;M-i,那么dp[i]=dp[2*M_idx-i], 其他情况，i的最长回文串最大坐标必定大于等于M,求dp[i]是从M向右移动的过程 最后dp[i]转成正在的程度，如果i位置是#,则返回(1+dp[i])//2*2,否则1+dp[i]//2*2 ''' if len(s)==0: return '' s2='#'.join(s) dp=[0 for i in range(len(s2))] M_idx=0 for i in range(1,len(s2)): M=M_idx+dp[M_idx] if M&gt;=i and dp[2*M_idx-i]&lt;M-i: dp[i]=dp[2*M_idx-i] else: t=max(M-i,1) while i+t&lt;len(s2) and i-t&gt;=0 and s2[i+t]==s2[i-t]: t+=1 dp[i]=t-1 idx=max(range(len(s2)),key=lambda i:1+dp[i]//2*2 if s2[i]!='#' else (1+dp[i])//2*2) return ''.join(s2[idx-dp[idx]:idx+dp[idx]+1].split('#'))","link":"/2020/03/03/Leetcode%205.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"uva","slug":"uva","link":"/tags/uva/"},{"name":"紫书","slug":"紫书","link":"/tags/%E7%B4%AB%E4%B9%A6/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"}],"categories":[{"name":"oj","slug":"oj","link":"/categories/oj/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"}]}