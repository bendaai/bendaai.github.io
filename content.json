{"pages":[],"posts":[{"title":"12. 整数转罗马数字","text":"情况不多，枚举一下所有位上可能的情况即可 题目内容 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 示例 1: 输入: 3输出: “III”示例 2: 输入: 4输出: “IV”示例 3: 输入: 9输出: “IX”示例 4: 输入: 58输出: “LVIII”解释: L = 50, V = 5, III = 3.示例 5: 输入: 1994输出: “MCMXCIV”解释: M = 1000, CM = 900, XC = 90, IV = 4. 题解class Solution: def intToRoman(self, num: int) -&gt; str: d4=['','M','MM','MMM'] d3=['','C','CC','CCC','CD','D','DC','DCC','DCCC','CM'] d2=['','X','XX','XXX','XL','L','LX','LXX','LXXX','XC'] d1=['','I','II','III','IV','V','VI','VII','VIII','IX'] ans='' ans+=d4[num//1000] num%=1000 ans+=d3[num//100] num%=100 ans+=d2[num//10] num%=10 ans+=d1[num] return ans","link":"/2020/03/06/12/"},{"title":"14. 最长公共前缀","text":"比较简单的题，依次遍历各个字符串的第k个数，如果字符串到结尾或者有两个字符串第k个位置的值不同，则结束 题目内容 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl”示例 2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。说明: 所有输入只包含小写字母 a-z 。 题解class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if len(strs)==0: return '' candidate=strs[0] i=0 while i&lt; len(candidate): e=candidate[i] for s in strs: if i&gt;=len(s) or s[i]!=candidate[i]: return candidate[:i] i+=1 return candidate[:i]","link":"/2020/03/06/14/"},{"title":"13. 罗马数字转整数","text":"根据右边位置符号代表的数来判断自身的正负。 题目内容 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 示例 1: 输入: “III”输出: 3示例 2: 输入: “IV”输出: 4示例 3: 输入: “IX”输出: 9示例 4: 输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3.示例 5: 输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 题解class Solution: def romanToInt(self, s: str) -&gt; int: dic={'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000} ans=0 for i in range(len(s)): if i==len(s)-1: ans+=dic[s[i]] else: if dic[s[i]]&gt;=dic[s[i+1]]: ans+=dic[s[i]] else: ans-=dic[s[i]] return ans","link":"/2020/03/06/13/"},{"title":"Leetcode 11.盛最多水的容器","text":"两端逼近法求最大面积 题目内容 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 示例:输入: [1,8,6,2,5,4,8,3,7]输出: 49 题解class Solution: def maxArea(self, height: List[int]) -&gt; int: ''' 逼近法 两端进行逼近 每次舍弃短边,因为不存在短边为边的另一个矩形比当前矩形要大【宽变小,高最多为短边】 ''' l,r=0,len(height)-1 ans=0 while l&lt;r: ans=max(ans,min(height[l],height[r])*(r-l)) if height[l]&gt;height[r]: r-=1 else: l+=1 return ans","link":"/2020/03/05/Leetcode%2011.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"title":"Leetcode 5. 最长回文子串","text":"马拉车算法，根据回文串的对称性质的动态规划方法，O(n)复杂度 题目内容 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 示例 1：输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2：输入: “cbbd”输出: “bb” 题解class Solution: def longestPalindrome(self, s: str) -&gt; str: ''' 马拉车算法： 对s进行#填充,得到s[0]#s[1]#s[2]...#s[-1]的形式， 这样每个位置的最大回文串都是奇数长度 dp[i]保存的是 i位置的最大回文串长度//2 过程中保存回文串可以达到的最远位置的状态 M_idx为该回文串的中心位置坐标，M为最远位置坐标.M=M_idx+dp[M_idx] 求dp[i]时，若i&lt;=M,我们可以得到i关于M_idx的对称点,2*M_idx-i,且由于对称性， 若dp[2*M_idx-i]&lt;M-i,那么dp[i]=dp[2*M_idx-i], 其他情况，i的最长回文串最大坐标必定大于等于M,求dp[i]是从M向右移动的过程 最后dp[i]转成原始字符串的长度，如果i位置是#,则返回(1+dp[i])//2*2,否则1+dp[i]//2*2 ''' if len(s)==0: return '' s2='#'.join(s) dp=[0 for i in range(len(s2))] M_idx=0 for i in range(1,len(s2)): M=M_idx+dp[M_idx] if M&gt;=i and dp[2*M_idx-i]&lt;M-i: dp[i]=dp[2*M_idx-i] else: t=max(M-i,1) while i+t&lt;len(s2) and i-t&gt;=0 and s2[i+t]==s2[i-t]: t+=1 dp[i]=t-1 idx=max(range(len(s2)),key=lambda i:1+dp[i]//2*2 if s2[i]!='#' else (1+dp[i])//2*2) return ''.join(s2[idx-dp[idx]:idx+dp[idx]+1].split('#'))","link":"/2020/03/03/Leetcode%205.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"Leetcode 6. Z 字形变换","text":"模拟题目情况，发现行数变化为1…numRows,numRows,…1…前后做差，为numRows+1个、numRows-1个-1循环 题目内容 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：L C I RE T O E S I I GE D H N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。请你实现这个将字符串进行指定行数变换的函数：string convert(string s, int numRows); 示例 示例 1:输入: s = “LEETCODEISHIRING”, numRows = 3输出: “LCIRETOESIIGEDHN”示例 2:输入: s = “LEETCODEISHIRING”, numRows = 4输出: “LDREOEIIECIHNTSG”解释:L D RE O E I IE C I H NT S G 题解class Solution: def convert(self, s: str, numRows: int) -&gt; str: if numRows&lt;=1: return s def nextdata(X): while 1: for i in X: yield i delta_list=[1]*(numRows-1)+[-1]*(numRows-1) c_delta=nextdata(delta_list) s_list=[[] for i in range(numRows)] idx=0 for e in s: s_list[idx].append(e) idx+=next(c_delta) return ''.join(map(lambda x:''.join(x),s_list))","link":"/2020/03/03/Leetcode%206.%20Z%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"},{"title":"Leetcode 3. 无重复字符的最长子串","text":"dp[k]保存以k位置字符为结尾的最长子串长度idx[e]保存e字符上一个出现的位置,如果没出现过，则认为上一个出现位置为-1动态规划方程：dp[k]=min(dp[k-1]+1,k-idx[s[k]]) 题目内容 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例: 示例1:输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2:输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3:输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 题解class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: ''' dp[k]保存以k位置字符为结尾的最长子串长度 idx[e]保存e字符上一个出现的位置,如果没出现过，则认为上一个出现位置为-1 动态规划方程：dp[k]=min(dp[k-1]+1,k-idx[s[k]]) ''' if s=='': return 0 dp=[1 for i in range(len(s))] idx={s[0]:0} for k in range(1,len(s)): dp[k]=min(dp[k-1]+1,k-idx.get(s[k],-1)) idx[s[k]]=k return max(dp) 还可对dp数组进行压缩 class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: ''' 动态规划方程：dp[k]=min(dp[k-1]+1,k-idx[s[k]]) dp[k]只和dp[k-1]有关，所以可以进行数组压缩 ''' if s=='': return 0 ans=1 dp=1 idx={s[0]:0} for k in range(1,len(s)): dp=min(dp+1,k-idx.get(s[k],-1)) ans=max(ans,dp) idx[s[k]]=k return ans","link":"/2020/03/02/Leetcode%203.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"Leetcode 10. 正则表达式匹配","text":"动态规划的一道题，难点在于想到如何表示状态。 题目内容 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘‘ 的正则表达式匹配。‘.’ 匹配任意单个字符‘‘ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 示例 1: 输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。示例 2: 输入:s = “aa”p = “a*”输出: true解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。示例 3: 输入:s = “ab”p = “.*”输出: true解释: “.*” 表示可匹配零个或多个（’*’）任意字符（’.’）。示例 4: 输入:s = “aab”p = “cab”输出: true解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。示例 5: 输入:s = “mississippi”p = “misis*p.”输出: false 题解class Solution: def isMatch(self, s: str, p: str) -&gt; bool: ''' dp[i][j]:代表s[i-1]和p[j-1]是否匹配 显然dp[0][0]=True,其他dp[][0]=False dp[i][j]的计算： 1.p[j-1]=='.':s[..i-2]和p[..j-2]匹配的话,为True :dp[i-1][j-1] 2.p[j-1]=='*:*代表0个的时候，和dp[i][j-2]一致 :*代表多个的时候，dp[i-1][j] &amp; p[j-2]和s[i-1]匹配 :dp[i][j-1] | dp[i-1][j] 3.其他情况：dp[i-1][j-1] &amp; s[i-1]==p[j-1] ''' dp=[[False for j in range(len(p)+1)] for i in range(len(s)+1)] dp[0][0]=True for i in range(0,len(s)+1): for j in range(1,len(p)+1): if p[j-1]=='.': if i-1&gt;=0: dp[i][j]=dp[i-1][j-1] elif p[j-1]=='*': dp[i][j]=dp[i][j-2] or (dp[i-1][j] and (p[j-2]=='.' or p[j-2]==s[i-1])) else: if i-1&gt;=0: dp[i][j]=dp[i-1][j-1] and (s[i-1]==p[j-1]) return dp[len(s)][len(p)]","link":"/2020/03/05/Leetcode%2010.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"title":"UVA 210. Concurrency Simulator","text":"逻辑其实挺清晰的，但是数据坑点很多,怀疑数据中可能有多的空行。 题目链接https://vjudge.net/problem/UVA-210 import sys import queue def _input(): lines=sys.stdin.readlines() for val in lines: x=val.strip() if x!='': yield x c=_input() def func(): n,t1,t2,t3,t4,t5,Q=list(map(int,next(c).split())) code_list=[] for i in range(n): que=queue.deque() while 1: s=next(c).strip() que.append(s) if s=='end': break code_list.append(que) block_que=queue.deque() wait_que=queue.deque() locked=0 var2val={} for i in range(n): wait_que.append(i) while len(wait_que)!=0: k=wait_que.popleft() t=Q while 1: s=code_list[k].popleft() if s=='end': break elif s=='lock': t-=t3 if locked==1: code_list[k].appendleft(s) block_que.append(k) break else: locked=1 elif s=='unlock': t-=t4 locked=0 if len(block_que)&gt;0: wait_que.appendleft(block_que.popleft()) elif '=' in s: t-=t1 var2val[s[0]]=s.split('=')[-1].strip() else: t-=t2 var=s[-1] print(f'{k+1}: {var2val.get(var,0)}') if t&lt;=0: wait_que.append(k) break T=int(next(c)) for i in range(T): if i&gt;0: print() func()","link":"/2020/03/02/UVA%20210.%20Concurrency%20Simulator/"},{"title":"Leetcode 2. 两数相加","text":"考察链表，链表的题都可以设置一个头结点，之后前插入或后插入 题目内容 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 #题解 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: ''' e表示为进位 pre作为返回链表的头结点，方便处理 10进制按位进行加法 注意情况： 一个链表结束，但有1的情况 ''' pre=ListNode(0) p=pre e=0 while l1 and l2: v=l1.val+l2.val+e l1.val,e=v%10,v//10 p.next=l1 p=l1 l1,l2=l1.next,l2.next if l2: p.next=l2 while e==1 and p.next: v=p.next.val+e e,p.next.val=v//10,v%10 p=p.next if e==1: p.next=ListNode(1) return pre.next","link":"/2020/03/02/Leetcode%202.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"title":"Leetcode 4. 寻找两个有序数组的中位数","text":"把问题统一为寻找中间两个数的问题，用二分查找寻找第k个数 题目内容 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 示例 示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0 2示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 题解class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: ''' 寻找中间两个元素 ''' def find_no_k(nums1,nums2,l1,l2,k): ''' 假设左右数组分别为AB 我们将查找A的min(k/2,len(A)),设为la 和B的k-la 得到A1,a,A2;B1,b,B2; 若a&lt;b,由于a&lt;{b,B2,A2},而除去{b,B2,A2}，两数组剩余不到k, 因此a的位置在k前面，既可以舍弃a,A1 若a==b,答案就是a 若a&gt;b,同理舍弃b,B1 ''' L1,L2=len(nums1)-l1,len(nums2)-l2 if L1&gt;L2:#保证nums1代表的长度短的，方便处理 return find_no_k(nums2,nums1,l2,l1,k) if L1==0: return nums2[l2+k-1] if k==1: return min(nums1[l1],nums2[l2]) la=min(k//2,L1) lb=k-la a,b=nums1[la+l1-1],nums2[lb+l2-1] if a&lt;b: return find_no_k(nums1,nums2,l1+la,l2,k-la) if a&gt;b: return find_no_k(nums1,nums2,l1,l2+lb,k-lb) return a L1,L2=len(nums1),len(nums2) return (find_no_k(nums1,nums2,0,0,(L1+L2)//2+1)+find_no_k(nums1,nums2,0,0,(L1+L2-1)//2+1))/2","link":"/2020/03/02/Leetcode%204.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"title":"Leetcode 7. 整数反转","text":"比较简单的一道题 题目内容 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 示例 1: 输入: 123输出: 321 示例 2: 输入: -123输出: -321示例 3: 输入: 120输出: 21注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 题解class Solution: def reverse(self, x: int) -&gt; int: if x&gt;=0: x= int(str(x)[::-1]) else: x= -int(str(-x)[::-1]) return x if x&gt;=-pow(2,31) and x&lt;=pow(2,31)-1 else 0","link":"/2020/03/05/Leetcode%207.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"},{"title":"正则表达式入门","text":"下午看了正则表达式必知必会，总结一波 注意，正则匹配机制是匹配到一串字符后，从匹配字符结尾的下一个位置，继续匹配 字符匹配层次单字符: ‘.’：匹配任意字符‘\\‘:转义元字符【’.’在”[]”内可以不进行转义】 多字符和的元字符:[]、’^’ “[abcd]”:abcd中的一个“[a-z]”:a到z中的一个“[^1-9]”:除了1到9，其他字符都可以 重复:”{}”、’+’、’*’、’?’k次重复上一个字符 ‘*’:[0,$\\infty$)‘+’:[1,$\\infty$)‘?’:{0,1}‘{a,b}:[a,b]‘{a}’:{a}‘{a,}:[a,$\\infty$) 以上都为贪婪型，即尽可能多的匹配，加上?变为懒惰型，如’*?’、’+?’、’{n,}?’不过，在线的正则表达式网站，加上?后只有第一个为懒惰，后面仍为贪婪型 特殊字符空白元字符 \\f:换页\\n:换行\\r:回车\\t:制表\\v:垂直制表 字母数字相关 \\d:[0-9]\\D:[^0-9]\\w:[a-zA-Z0-9_]\\W:[^a-zA-Z0-9_]\\s:[\\f\\n\\r\\t\\v]任一空白字符\\S:[^\\f\\n\\r\\t\\v] POSIX字符类 [:blank:]:[\\t ][:cntrl:]:ASCII控制字符，ASCII0-31、ASCII127[:digit:]:[0-9][:print:]:任一个可打印字符[:graph:]:[:print:]不包括空格[:lower:]:[a-z][:upper:]:[A-Z][:punct:]:既不属于:alnum:也不属于[:cntrl:][:space:]:[\\f\\n\\r\\t\\v][:xdigit:]:[a-fA-F0-9] 使用:[[:digit:]]双括号表示 位置匹配 \\b:单词开始或结尾\\B:不匹配单词边界^:字符串开始边界，在[]中代表的是取反$:字符串结束边界(^m):放在开头表示字符串行分隔符作为字符串边界对待\\A:字符串开始，不随(^m)改变行为，但又有些不支持\\Z:字符串结尾，不随(^m)改变行为，但又有些不支持 表达式和替换子表达式:’|’、”()”通过”()”把子串作为一个整体,比如(&nbsp;){2}代表&nbsp;&nbsp;子表达式嵌套：((x)|(y)):(x)或者(y) 回溯引用：前后一致匹配:”\\k”“(x).*\\1” : \\1代表的就是(x)【\\k代表的是第k个子表达式】 表达式在替换中的应用:’$’find:(\\w+[\\w\\.]*@[\\w\\.]+\\.\\w+)【邮箱地址】 replace: &lt;A HREF=&quot;mailto:$1&quot;&gt;$1&lt;/A&gt;【跨模式使用】 替换中大小写转换 \\E:结束\\L或\\U转换\\l:下一个转为小写\\L:\\L到\\E转为小写\\u:下一个转为大写\\U:\\U到\\E转为大写 前后查找查找到的字符串的一部分http://www.forta.com/前向查找”(?=)”–&gt;”.+(?=:)”–&gt;搜索到的是http【后接串匹配】 (?=) 正向前查找(?!) 负向前查找【后接串不匹配的子串】(?&lt;!) 正向后查找(?&lt;!) 负向后查找【前接串不匹配的子串】 嵌入条件: (?(condition)true-regex|false-regex)condition存在的时候，为true-regex否则false-regex，其中|false-regex可以省略 condition:回溯引用条件【根据子表达式来if】&quot;(x).\\*(?(1)x|y)&quot; 如果(x)存在：&quot;(x).\\*x&quot;不存在&quot;(x).\\*y&quot; condition:前后查找条件【根据前后串的情况来进行if】对于5数字和5数子-4数字两种情况【14789-1589、15979】\\d{5}(?(?=-)-\\d{4})","link":"/2020/03/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"Leetcode 8. 字符串转换整数 (atoi)","text":"按题目逻辑写代码即可 题目内容 请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 示例 1:输入: “42”输出: 42示例 2:输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3: 输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。示例 4: 输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 题解class Solution: def myAtoi(self, str: str) -&gt; int: str=str.strip() if len(str)==0: return 0 sign=1 if str[0]=='-' or str[0]=='+': sign=-1 if str[0]=='-' else 1 str=str[1:] i=0 while i&lt;len(str): if str[i]&lt;'0' or str[i]&gt;'9': break i+=1 INT_MAX,INT_MIN=2**31-1,-2**31 if i==0: return 0 ans=sign*int(str[:i]) if ans&gt;INT_MAX: ans=INT_MAX if ans&lt;INT_MIN: ans=INT_MIN return ans","link":"/2020/03/05/Leetcode%208.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/"},{"title":"Leetcode 9. 回文数","text":"很简单的一道题 题目内容 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 示例 1:输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶:你能不将整数转为字符串来解决这个问题吗？ 题解class Solution: def isPalindrome(self, x: int) -&gt; bool: x=str(x) return x==x[::-1]","link":"/2020/03/05/Leetcode%209.%20%E5%9B%9E%E6%96%87%E6%95%B0/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"uva","slug":"uva","link":"/tags/uva/"},{"name":"紫书","slug":"紫书","link":"/tags/%E7%B4%AB%E4%B9%A6/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"}],"categories":[{"name":"oj","slug":"oj","link":"/categories/oj/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"}]}