{"pages":[{"title":"","text":"google-site-verification: google343c04080cac883e.html","link":"/google343c04080cac883e.html"},{"title":"","text":"3IFp7Fsh6W","link":"/baidu_verify_3IFp7Fsh6W.html"}],"posts":[{"title":"UVA - 1160 X-Plosives","text":"考察并查集的知识，不能出现环路，即不能有两个属于同一个领域的个体合并。 题目链接https://vjudge.net/problem/UVA-1160 def x_plosives(maxn): def find_fa(x): fa[x]=find_fa(fa[x]) if x!=fa[x] else x return fa[x] def union(x,y): fx=find_fa(x) fy=find_fa(y) if fx==fy: return False fa[fx]=fa[fy]=min(fx,fy) return True import sys stream=sys.stdin # stream=open('0.txt') s='1' while True: fa=[i for i in range(100000+5)] ans=0 while True: s=stream.readline().strip() if not s: break if s=='-1': stream.readline() break x,y=list(map(int,s.split())) if not union(x,y): ans+=1 if not s: break print(ans) if __name__=='__main__': x_plosives(100000+5)","link":"/2020/03/09/1160/"},{"title":"12. 整数转罗马数字","text":"情况不多，枚举一下所有位上可能的情况即可 题目内容 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 示例 1: 输入: 3输出: “III”示例 2: 输入: 4输出: “IV”示例 3: 输入: 9输出: “IX”示例 4: 输入: 58输出: “LVIII”解释: L = 50, V = 5, III = 3.示例 5: 输入: 1994输出: “MCMXCIV”解释: M = 1000, CM = 900, XC = 90, IV = 4. 题解class Solution: def intToRoman(self, num: int) -&gt; str: d4=['','M','MM','MMM'] d3=['','C','CC','CCC','CD','D','DC','DCC','DCCC','CM'] d2=['','X','XX','XXX','XL','L','LX','LXX','LXXX','XC'] d1=['','I','II','III','IV','V','VI','VII','VIII','IX'] ans='' ans+=d4[num//1000] num%=1000 ans+=d3[num//100] num%=100 ans+=d2[num//10] num%=10 ans+=d1[num] return ans","link":"/2020/03/06/12/"},{"title":"13. 罗马数字转整数","text":"根据右边位置符号代表的数来判断自身的正负。 题目内容 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 示例 1: 输入: “III”输出: 3示例 2: 输入: “IV”输出: 4示例 3: 输入: “IX”输出: 9示例 4: 输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3.示例 5: 输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 题解class Solution: def romanToInt(self, s: str) -&gt; int: dic={'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000} ans=0 for i in range(len(s)): if i==len(s)-1: ans+=dic[s[i]] else: if dic[s[i]]&gt;=dic[s[i+1]]: ans+=dic[s[i]] else: ans-=dic[s[i]] return ans","link":"/2020/03/06/13/"},{"title":"15. 三数之和","text":"当时2个数加起来为target时，可用逼近法【每一组的值都不可能有一个一样的，否则会重复】其他情况，不能重复使用与前一个位置的值一样的数来进行搜索【第l个值包括了后面的情况】 题目内容 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 题解class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums=sorted(nums) ans=[] for i in range(len(nums)-1): if i!=0 and nums[i]==nums[i-1]: continue target=-nums[i] l,r=i+1,len(nums)-1 while l&lt;r: _sum=nums[l]+nums[r] if _sum&gt;target: r-=1 elif _sum&lt;target: l+=1 else: ans.append([nums[i],nums[l],nums[r]]) l_val,r_val=nums[l],nums[r] while l&lt;r and nums[l]==l_val: l+=1 while l&lt;r and nums[r]==r_val: r-=1 return ans","link":"/2020/03/07/15/"},{"title":"14. 最长公共前缀","text":"比较简单的题，依次遍历各个字符串的第k个数，如果字符串到结尾或者有两个字符串第k个位置的值不同，则结束 题目内容 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl”示例 2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。说明: 所有输入只包含小写字母 a-z 。 题解class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if len(strs)==0: return '' candidate=strs[0] i=0 while i&lt; len(candidate): e=candidate[i] for s in strs: if i&gt;=len(s) or s[i]!=candidate[i]: return candidate[:i] i+=1 return candidate[:i]","link":"/2020/03/06/14/"},{"title":"17. 电话号码的字母组合","text":"注意考虑digits空的情况。深搜的方式 题目内容 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。dig2str=[‘abc’,’def’,’ghi’,’jkl’,’mno’,’pqrs’,’tuv’,’wxyz’] 示例 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 题解class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: if digits=='': return [] ans=[] t=[] dig2str=['abc','def','ghi','jkl','mno','pqrs','tuv','wxyz'] def dfs(digits,idx,t): if idx==len(digits): ans.append(''.join(t)) return dig=int(digits[idx]) for e in dig2str[dig-2]: t.append(e) dfs(digits,idx+1,t) t.pop() dfs(digits,0,t) return ans","link":"/2020/03/07/17/"},{"title":"18. 四数之和","text":"借用Leetcode15题的函数，即排序后，我选定一个值，再右边的数组中寻找target为x的三元组，再合并 题目内容 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意： 答案中不可以包含重复的四元组。 示例 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 题解class Solution: def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]: ans=[] nums=sorted(nums) def threeSum(nums,left,_target): ans=[] for i in range(left,len(nums)-1): if i!=left and nums[i]==nums[i-1]: continue target=_target-nums[i] l,r=i+1,len(nums)-1 while l&lt;r: _sum=nums[l]+nums[r] if _sum&gt;target: r-=1 elif _sum&lt;target: l+=1 else: ans.append([nums[i],nums[l],nums[r]]) l_val,r_val=nums[l],nums[r] while l&lt;r and nums[l]==l_val: l+=1 while l&lt;r and nums[r]==r_val: r-=1 return ans for i in range(len(nums)-3): if i!=0 and nums[i]==nums[i-1]: continue _target=target-nums[i] _ans=threeSum(nums,i+1,_target) ans.extend([[nums[i]]+lis for lis in _ans]) return ans","link":"/2020/03/07/18/"},{"title":"16. 最接近的三数之和","text":"对leetcode 15的函数略作修改即可 题目内容 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 题解class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: nums=sorted(nums) ans=nums[0]+nums[1]+nums[2] diff=abs(ans-target) for i in range(len(nums)-1): if i!=0 and nums[i]==nums[i-1]: continue _target=target-nums[i] l,r=i+1,len(nums)-1 while l&lt;r: _sum=nums[l]+nums[r] if diff&gt;abs(_target-_sum): diff=abs(_target-_sum) ans=_sum+nums[i] if _sum&gt;_target: r-=1 elif _sum&lt;_target: l+=1 else: return target return ans","link":"/2020/03/07/16/"},{"title":"23. 合并K个排序链表","text":"和leetcode21类似，只是选取每个链首最小值的时候用优先队列 题目内容 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例 输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 题解# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: from queue import PriorityQueue que=PriorityQueue() for i,p in enumerate(lists): if p: que.put([p.val,i]) pre=ListNode(0) p=pre while not que.empty(): t=que.get()[1] p.next=lists[t] p=lists[t] lists[t]=lists[t].next if lists[t]: que.put([lists[t].val,t]) return pre.next","link":"/2020/03/11/23/"},{"title":"20. 有效的括号","text":"用栈来模拟流程中的匹配。 题目内容 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 示例 1: 输入: “()”输出: true示例 2: 输入: “()[]{}”输出: true示例 3: 输入: “(]”输出: false示例 4: 输入: “([)]”输出: false示例 5: 输入: “{[]}”输出: true 题解class Solution: def isValid(self, s: str) -&gt; bool: ''' 用栈了模拟，左括号压栈。 每次遇到右括号必须和栈顶的左括号匹配，并且栈顶左括号出栈。 结束时要保证栈为空。 ''' sta=[] l2r={'}':'{',')':'(',']':'['} for e in s: if e in '([{': sta.append(e) else: if len(sta)&gt;0 and l2r[e]==sta[-1]: sta.pop() else: return False return len(sta)==0","link":"/2020/03/08/20/"},{"title":"24. 两两交换链表中的节点","text":"注意结束的边界：如果p后面后两个结点，交换p.next和p.next.next,并返回True,交换后的p.next.next；否则返回False 题目内容 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 题解# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: def swapnode(p): ''' 如果p后面后两个结点，交换p.next和p.next.next,并返回True,交换后的p.next.next 否则返回False, ''' if p.next and p.next.next: l=p.next r=p.next.next l.next=r.next p.next=r r.next=l return True,p.next.next return False, pre=ListNode(0) pre.next=head p=pre while True: r=swapnode(p) if r[0]==False: break p=r[1] return pre.next","link":"/2020/03/11/24/"},{"title":"25. K 个一组翻转链表","text":"和leetcode24类似，先判断之后是否有k个结点，如果有则倒序后k个结点，这里可以用递归的思路。 题目内容 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例 给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 题解# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: def reverse_k(n1,k,l): if k==1: l.next=n1 return n1 reverse_k(n1.next,k-1,l).next=n1 return n1 pre=ListNode(0) pre.next=head l=pre n1=l.next while 1: t=n1 for i in range(k): if t==None: l.next=n1 return pre.next t=t.next reverse_k(n1,k,l).next=t l,n1=n1,t return pre.next","link":"/2020/03/11/25/"},{"title":"26. 删除排序数组中的重复项","text":"比较简单的题，维护2指针，一个对应遍历nums的位置，另一个对应该值如果取到的插入位置 题目内容 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 示例 1:给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 题解class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: i,j=0,1 while j&lt;len(nums): if nums[j]!=nums[i]: nums[i+1]=nums[j] i+=1 j+=1 return i+1","link":"/2020/03/11/26/"},{"title":"27. 移除元素","text":"简单题，和leetcode26类似，统一维护两个指针。 题目内容 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 示例 1:给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 题解class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: i,j=0,0 while j&lt;len(nums): if nums[j]!=val: nums[i]=nums[j] i+=1 j+=1 return i","link":"/2020/03/11/27/"},{"title":"28. 实现 strStr()","text":"使用kmp来进行字符串匹配 题目内容 实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 示例 1:输入: haystack = “hello”, needle = “ll”输出: 2示例 2:输入: haystack = “aaaaa”, needle = “bba”输出: -1 题解class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: def KMP(s,p): def get_nextval(p): L=len(p) nextval=[-1 for i in range(L)] i,j=0,-1 while i+1&lt;L: if j==-1 or p[j]==p[i]: i+=1 j+=1 nextval[i]=j if p[j]!=p[i] else nextval[j] else: j=nextval[j] return nextval nextval=get_nextval(p) i,j=0,0 while i&lt;len(s) and j&lt;len(p): if j==-1 or s[i]==p[j]: i+=1 j+=1 else: j=nextval[j] return i-len(p) if j==len(p) else -1 return KMP(haystack,needle)","link":"/2020/03/11/28/"},{"title":"29. 两数相除","text":"倍增divisor，每次将结果保存到divisor_multiadd_list，divisor_multiadd_list[k]=2^k * divisor注意溢出处理 题目内容 定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。 示例 示例 1:输入: dividend = 10, divisor = 3输出: 3示例 2:输入: dividend = 7, divisor = -3输出: -2 题解class Solution: ''' 倍增divisor，每次将结果保存到divisor_multiadd_list， divisor_multiadd_list[k]=2^k * divisor ''' def divide(self, dividend: int, divisor: int) -&gt; int: #溢出处理 if dividend==-2**31 and divisor==-1: return 2**31-1 flag=1 if dividend^divisor &gt;=0 else -1 dividend,divisor=abs(dividend),abs(divisor) divisor_multiadd_list=[] while divisor&lt;=dividend: divisor_multiadd_list.append(divisor) divisor+=divisor ans=0 for idx in range(len(divisor_multiadd_list)-1,-1,-1): if dividend&gt;=divisor_multiadd_list[idx]: dividend-=divisor_multiadd_list[idx] ans+=(1&lt;&lt;idx) return flag*ans","link":"/2020/03/11/29/"},{"title":"22. 括号生成","text":"深搜，注意边界即可 题目内容 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 示例 例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 题解class Solution: def generateParenthesis(self, n: int) -&gt; List[str]: ''' 深搜，每次生成的时候， 如果目标左括号比较多，则可以右括号也可以左括号 否则只能加入左括号 注意括号个数的限制即可 ''' ans=[] def dfs(num_l,num_r,n,t): if num_l&lt;n: t.append('(') dfs(num_l+1,num_r,n,t) t.pop() else: ans.append(''.join(t)+')'*(num_l-num_r)) return if num_l&gt;num_r: t.append(')') dfs(num_l,num_r+1,n,t) t.pop() t=[] dfs(0,0,n,t) return ans","link":"/2020/03/08/22/"},{"title":"19. 删除链表的倒数第N个节点","text":"链表题，一般先建立一个元结点指向首节点。该题维护两个指针向前过程中距离不变的特性。 题目内容 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例 示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明： 给定的 n 保证是有效的。 进阶：你能尝试使用一趟扫描实现吗？ 题解# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: ''' 删除第k个结点，所需要的是第k-1个结点的信息，我们用一个元结点pre指向head。 如果删除的是倒数第一个，那么我们所需的结点为倒数第二个，该节点距离尾结点1 如果删除的是倒数第k个，那么所需节点为倒数第k-1个，该节点距离尾结点k 因此，我们让p结点先行k，pl结点和p结点再一块向前，直到p结点为尾结点【p.next=None】 如此我们维护了p和pl结点距离为k的不变性，p为尾结点时，pl即为我们所需节点，pl.next即为要删除的结点 ''' pre=ListNode(0) pre.next=head p,pl=pre,pre for i in range(n): p=p.next while p.next!=None: p=p.next pl=pl.next pl.next=pl.next.next return pre.next","link":"/2020/03/08/19/"},{"title":"21. 合并两个有序链表","text":"新建一个链表，每次取l1、l2链首小的元素，取后链表的首结点进1 题目内容 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 题解# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: ''' 新建一个链表，每次取l1、l2链首小的元素，取后链表的首结点进1 ''' pre=ListNode(0) p=pre while l1 and l2: if l1.val&lt;l2.val: p.next=l1 p=l1 l1=l1.next else: p.next=l2 p=l2 l2=l2.next if l2: p.next=l2 else: p.next=l1 return pre.next","link":"/2020/03/08/21/"},{"title":"KMP模板","text":"经典的字符串匹配算法 模板def KMP(s,p): def get_nextval(p): L=len(p) nextval=[-1 for i in range(L)] i,j=0,-1 while i+1&lt;L: if j==-1 or p[j]==p[i]: i+=1 j+=1 nextval[i]=j if p[j]!=p[i] else nextval[j] else: j=nextval[j] return nextval nextval=get_nextval(p) i,j=0,0 while i&lt;len(s) and j&lt;len(p): if j==-1 or s[i]==p[j]: i+=1 j+=1 else: j=nextval[j] return i-len(p) if j==len(p) else -1","link":"/2020/03/11/KMP%E6%A8%A1%E6%9D%BF/"},{"title":"UVA - 442 Matrix Chain Multiplication | 紫书 6-3","text":"用栈来保存数组shape，如果用到’)’，则表示栈顶的两个元素相乘，不过要栈顶是B，次栈顶为A。 题目链接https://vjudge.net/problem/UVA-442 import sys def _input(): lines=sys.stdin.read().split('\\n') for val in lines: x=val.strip() if x!='': yield val c=_input() n=int(next(c)) dic={} def multi(A,B): #return not_error,cnt,new matrix # A [a1,a2] # B [b1,b2] if A[1]!=B[0]: return [False] return True,A[0]*A[1]*B[1],[A[0],B[1]] for i in range(n): t=next(c).split() dic[t[0]]=[int(t[1]),int(t[2])] for val in c: sta=[] ans=0 for e in val: if e==')': B=sta.pop() A=sta.pop() re=multi(A,B) if re[0]==False: ans='error' break ans+=re[1] sta.append(re[2]) elif e!='(': sta.append(dic[e]) print(ans)","link":"/2020/03/07/6-3/"},{"title":"UVA - 514 Rails | 紫书6-2","text":"用栈模拟出栈顺序 题目链接https://vjudge.net/problem/UVA-514 import sys def _input(): lines=sys.stdin.read().split('\\n') for val in lines: x=val.strip() if x!='': yield val c=_input() while 1: n=int(next(c)) if n==0: break while 1: sta=[] pop_list=list(map(int,next(c).split())) if pop_list[0]==0: print() break k=0 i=1 while i&lt;=n: if len(sta)==0 or pop_list[k]!=sta[-1]: sta.append(i) i+=1 else: sta.pop() k+=1 while len(sta)&gt;0 and sta[-1]==pop_list[k]: k+=1 sta.pop() if len(sta)&gt;0: print('No') else: print('Yes')","link":"/2020/03/07/6-2/"},{"title":"Leetcode 2. 两数相加","text":"考察链表，链表的题都可以设置一个头结点，之后前插入或后插入 题目内容 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 #题解 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: ''' e表示为进位 pre作为返回链表的头结点，方便处理 10进制按位进行加法 注意情况： 一个链表结束，但有1的情况 ''' pre=ListNode(0) p=pre e=0 while l1 and l2: v=l1.val+l2.val+e l1.val,e=v%10,v//10 p.next=l1 p=l1 l1,l2=l1.next,l2.next if l2: p.next=l2 while e==1 and p.next: v=p.next.val+e e,p.next.val=v//10,v%10 p=p.next if e==1: p.next=ListNode(1) return pre.next","link":"/2020/03/02/Leetcode%202.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"title":"Leetcode 11.盛最多水的容器","text":"两端逼近法求最大面积 题目内容 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 示例:输入: [1,8,6,2,5,4,8,3,7]输出: 49 题解class Solution: def maxArea(self, height: List[int]) -&gt; int: ''' 逼近法 两端进行逼近 每次舍弃短边,因为不存在短边为边的另一个矩形比当前矩形要大【宽变小,高最多为短边】 ''' l,r=0,len(height)-1 ans=0 while l&lt;r: ans=max(ans,min(height[l],height[r])*(r-l)) if height[l]&gt;height[r]: r-=1 else: l+=1 return ans","link":"/2020/03/05/Leetcode%2011.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"title":"Leetcode 5. 最长回文子串","text":"马拉车算法，根据回文串的对称性质的动态规划方法，O(n)复杂度 题目内容 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 示例 1：输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2：输入: “cbbd”输出: “bb” 题解class Solution: def longestPalindrome(self, s: str) -&gt; str: ''' 马拉车算法： 对s进行#填充,得到s[0]#s[1]#s[2]...#s[-1]的形式， 这样每个位置的最大回文串都是奇数长度 dp[i]保存的是 i位置的最大回文串长度//2 过程中保存回文串可以达到的最远位置的状态 M_idx为该回文串的中心位置坐标，M为最远位置坐标.M=M_idx+dp[M_idx] 求dp[i]时，若i&lt;=M,我们可以得到i关于M_idx的对称点,2*M_idx-i,且由于对称性， 若dp[2*M_idx-i]&lt;M-i,那么dp[i]=dp[2*M_idx-i], 其他情况，i的最长回文串最大坐标必定大于等于M,求dp[i]是从M向右移动的过程 最后dp[i]转成原始字符串的长度，如果i位置是#,则返回(1+dp[i])//2*2,否则1+dp[i]//2*2 ''' if len(s)==0: return '' s2='#'.join(s) dp=[0 for i in range(len(s2))] M_idx=0 for i in range(1,len(s2)): M=M_idx+dp[M_idx] if M&gt;=i and dp[2*M_idx-i]&lt;M-i: dp[i]=dp[2*M_idx-i] else: t=max(M-i,1) while i+t&lt;len(s2) and i-t&gt;=0 and s2[i+t]==s2[i-t]: t+=1 dp[i]=t-1 idx=max(range(len(s2)),key=lambda i:1+dp[i]//2*2 if s2[i]!='#' else (1+dp[i])//2*2) return ''.join(s2[idx-dp[idx]:idx+dp[idx]+1].split('#'))","link":"/2020/03/03/Leetcode%205.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"Leetcode 10. 正则表达式匹配","text":"动态规划的一道题，难点在于想到如何表示状态。 题目内容 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘‘ 的正则表达式匹配。‘.’ 匹配任意单个字符‘‘ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 示例 1: 输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。示例 2: 输入:s = “aa”p = “a*”输出: true解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。示例 3: 输入:s = “ab”p = “.*”输出: true解释: “.*” 表示可匹配零个或多个（’*’）任意字符（’.’）。示例 4: 输入:s = “aab”p = “cab”输出: true解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。示例 5: 输入:s = “mississippi”p = “misis*p.”输出: false 题解class Solution: def isMatch(self, s: str, p: str) -&gt; bool: ''' dp[i][j]:代表s[i-1]和p[j-1]是否匹配 显然dp[0][0]=True,其他dp[][0]=False dp[i][j]的计算： 1.p[j-1]=='.':s[..i-2]和p[..j-2]匹配的话,为True :dp[i-1][j-1] 2.p[j-1]=='*:*代表0个的时候，和dp[i][j-2]一致 :*代表多个的时候，dp[i-1][j] &amp; p[j-2]和s[i-1]匹配 :dp[i][j-1] | dp[i-1][j] 3.其他情况：dp[i-1][j-1] &amp; s[i-1]==p[j-1] ''' dp=[[False for j in range(len(p)+1)] for i in range(len(s)+1)] dp[0][0]=True for i in range(0,len(s)+1): for j in range(1,len(p)+1): if p[j-1]=='.': if i-1&gt;=0: dp[i][j]=dp[i-1][j-1] elif p[j-1]=='*': dp[i][j]=dp[i][j-2] or (dp[i-1][j] and (p[j-2]=='.' or p[j-2]==s[i-1])) else: if i-1&gt;=0: dp[i][j]=dp[i-1][j-1] and (s[i-1]==p[j-1]) return dp[len(s)][len(p)]","link":"/2020/03/05/Leetcode%2010.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"title":"Leetcode 3. 无重复字符的最长子串","text":"dp[k]保存以k位置字符为结尾的最长子串长度idx[e]保存e字符上一个出现的位置,如果没出现过，则认为上一个出现位置为-1动态规划方程：dp[k]=min(dp[k-1]+1,k-idx[s[k]]) 题目内容 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例: 示例1:输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2:输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3:输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 题解class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: ''' dp[k]保存以k位置字符为结尾的最长子串长度 idx[e]保存e字符上一个出现的位置,如果没出现过，则认为上一个出现位置为-1 动态规划方程：dp[k]=min(dp[k-1]+1,k-idx[s[k]]) ''' if s=='': return 0 dp=[1 for i in range(len(s))] idx={s[0]:0} for k in range(1,len(s)): dp[k]=min(dp[k-1]+1,k-idx.get(s[k],-1)) idx[s[k]]=k return max(dp) 还可对dp数组进行压缩 class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: ''' 动态规划方程：dp[k]=min(dp[k-1]+1,k-idx[s[k]]) dp[k]只和dp[k-1]有关，所以可以进行数组压缩 ''' if s=='': return 0 ans=1 dp=1 idx={s[0]:0} for k in range(1,len(s)): dp=min(dp+1,k-idx.get(s[k],-1)) ans=max(ans,dp) idx[s[k]]=k return ans","link":"/2020/03/02/Leetcode%203.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"Leetcode 6. Z 字形变换","text":"模拟题目情况，发现行数变化为1…numRows,numRows,…1…前后做差，为numRows+1个、numRows-1个-1循环 题目内容 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：L C I RE T O E S I I GE D H N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。请你实现这个将字符串进行指定行数变换的函数：string convert(string s, int numRows); 示例 示例 1:输入: s = “LEETCODEISHIRING”, numRows = 3输出: “LCIRETOESIIGEDHN”示例 2:输入: s = “LEETCODEISHIRING”, numRows = 4输出: “LDREOEIIECIHNTSG”解释:L D RE O E I IE C I H NT S G 题解class Solution: def convert(self, s: str, numRows: int) -&gt; str: if numRows&lt;=1: return s def nextdata(X): while 1: for i in X: yield i delta_list=[1]*(numRows-1)+[-1]*(numRows-1) c_delta=nextdata(delta_list) s_list=[[] for i in range(numRows)] idx=0 for e in s: s_list[idx].append(e) idx+=next(c_delta) return ''.join(map(lambda x:''.join(x),s_list))","link":"/2020/03/03/Leetcode%206.%20Z%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"},{"title":"Leetcode 9. 回文数","text":"很简单的一道题 题目内容 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 示例 1:输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶:你能不将整数转为字符串来解决这个问题吗？ 题解class Solution: def isPalindrome(self, x: int) -&gt; bool: x=str(x) return x==x[::-1]","link":"/2020/03/05/Leetcode%209.%20%E5%9B%9E%E6%96%87%E6%95%B0/"},{"title":"RMQ模板","text":"范围最小值问题（Range Minimum Query, RMQ）。给出一个n个元素的数组A1，A2，…，An，设计一个数据结构，支持查询操作Query（L，R）：计算min｛AL，AL＋1，…，AR｝。 模板 Tarjan的Sparse-Table算法，它预处理的时间是O（nlogn），但是查询只需要O（1），而且常数很小。算法：令d（j,i）表示从i开始的，长度为$2^j$的一段元素中的最小值，则可以用递推的方法计算d（j,i）：$$d（j,i）＝min｛d（j－1,i），d（j－1,i＋2^{j－1}）｝$$查询[L,R],令k为满足$2^k\\le R-L+1$的最大整数$$min(d[k][L],d[k][R-(1&lt;&lt;k)+1]$$ def init_RMQ(A): n=len(A) k=1 while (1&lt;&lt;k)&lt;=n: k+=1 dp=[[0 for i in range(n)] for j in range(k)] for i in range(n): dp[0][i]=A[i] for j in range(1,k): for i in range(n): if i+(1&lt;&lt;j)&gt;n: break dp[j][i]=min(dp[j-1][i],dp[j-1][i+(1&lt;&lt;(j-1))]) return dp def find_min(L,R,dp): k=0 while (1&lt;&lt;k)&lt;=(R-L+1): k+=1 k-=1 return min(dp[k][L],dp[k][R+1-(1&lt;&lt;k)]) A=[1,3,-8,4] dp=init_RMQ(A) print(dp)#[[1, 3, -8, 4], [1, -8, -8, 0], [-8, 0, 0, 0]] find_min(1,3,dp)#-8","link":"/2020/03/10/RMQ%E6%A8%A1%E6%9D%BF/"},{"title":"Trie模板","text":"前缀树模板 模板class Node(object): def __init__(self,v=None): ''' 如果是结尾,val为该字符串的长度。否则是None ''' self.next=[0 for i in range(26)] self.val=v class Trie(object): def __init__(self,maxn): self.T=[Node() for i in range(maxn)] self.sz=1 def insert(self,s): root=0 for e in s: t=ord(e)-ord('a') if self.T[root].next[t]==0: self.T[root].next[t]=self.sz self.sz+=1 root=self.T[root].next[t] self.T[root].val=len(s) def query(self,s): root=0 for e in s: t=ord(e)-ord('a') if self.T[root].next[t]==0: return False root=self.T[root].next[t] return self.T[root].val != None maxn=int(1e5+5) T=Trie(maxn) for s in ['ab','weaf','sdigje','ccc']: T.insert(s) print(T.query('wea'))","link":"/2020/03/11/Trie%E6%A8%A1%E6%9D%BF/"},{"title":"Leetcode 4. 寻找两个有序数组的中位数","text":"把问题统一为寻找中间两个数的问题，用二分查找寻找第k个数 题目内容 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 示例 示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0 2示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 题解class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: ''' 寻找中间两个元素 ''' def find_no_k(nums1,nums2,l1,l2,k): ''' 假设左右数组分别为AB 我们将查找A的min(k/2,len(A)),设为la 和B的k-la 得到A1,a,A2;B1,b,B2; 若a&lt;b,由于a&lt;{b,B2,A2},而除去{b,B2,A2}，两数组剩余不到k, 因此a的位置在k前面，既可以舍弃a,A1 若a==b,答案就是a 若a&gt;b,同理舍弃b,B1 ''' L1,L2=len(nums1)-l1,len(nums2)-l2 if L1&gt;L2:#保证nums1代表的长度短的，方便处理 return find_no_k(nums2,nums1,l2,l1,k) if L1==0: return nums2[l2+k-1] if k==1: return min(nums1[l1],nums2[l2]) la=min(k//2,L1) lb=k-la a,b=nums1[la+l1-1],nums2[lb+l2-1] if a&lt;b: return find_no_k(nums1,nums2,l1+la,l2,k-la) if a&gt;b: return find_no_k(nums1,nums2,l1,l2+lb,k-lb) return a L1,L2=len(nums1),len(nums2) return (find_no_k(nums1,nums2,0,0,(L1+L2)//2+1)+find_no_k(nums1,nums2,0,0,(L1+L2-1)//2+1))/2","link":"/2020/03/02/Leetcode%204.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"title":"并查集模板","text":"比较简单的一种结构，假设每个个体都有各自的领域，开始每个个体的领域即为自己的名字。支持两种操作。1.将A的领域和B的领域合并为一个领域，领域名更改为最小个体的名字。2.查找A属于哪个领域。 模板maxn=100000+5 fa=[i for i in range(maxn)] def find_fa(x): fa[x]=find_fa(fa[x]) if x==fa[x] else x return fa[x] def union(x,y): fx=find_fa(x) fy=find_fa(y) fa[fx]=fa[fy]=min(fx,fy)","link":"/2020/03/09/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF/"},{"title":"树状数组模板","text":"Add（x，d）操作：让Ax增加d。Query（0，R）：计算AL＋AL＋1＋…＋AR。 模板maxn=100000+5 T=[0 for i in range(maxn)] lowbit=lambda x:x&amp;-x def Add(x,d): while x&lt;maxn: T[x]+=d x+=lowbit(x) def get_sum(x): ans=0 while x!=0: ans+=T[x] x-=lowbit(x) return ans Add(1,5) Add(10,88) print(get_sum(2))#5 print(get_sum(10))#93 Add(1,-2) print(get_sum(20))#91","link":"/2020/03/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF/"},{"title":"线段树模板","text":"动态范围最小值问题。给出一个有n个元素的数组A1，A2，…，An，你的任务是设计一个数据结构，支持以下操作Update（x，v）：把Ax修改为v。Query（L，R）：计算min｛AL，AL＋1，…，AR｝。Add（L，R，v）：把AL，AL＋1，…，AR的值全部增加v。Set（L，R，v）：把AL，AL＋1，…，AR的值全部设置为v。Mul（L，R，v）：把AL，AL＋1，…，AR的值全部乘上v。Query（L，R）：计算子序列AL，AL＋1，…，AR的元素和、最小值和最大值。 模板''' # 线段树 动态范围最小值问题。给出一个有n个元素的数组A1，A2，…，An，你的任务是设计一个数据结构，支持以下操作 Update（x，v）：把Ax修改为v。 Query（L，R）：计算min｛AL，AL＋1，…，AR｝。 Add（L，R，v）：把AL，AL＋1，…，AR的值全部增加v。 Set（L，R，v）：把AL，AL＋1，…，AR的值全部设置为v。 Mul（L，R，v）：把AL，AL＋1，…，AR的值全部乘上v。 Query（L，R）：计算子序列AL，AL＋1，…，AR的元素和、最小值和最大值。 ''' maxn=int(1e5+5) import queue class Node(object): def __init__(self,v=0): self.minv=v self.maxv=v self.sumv=v self.slz=None self.plz=0 self.mlz=1 def add_lazy(self,func,v,l,r): if func=='set': self.plz,self.mlz=0,1 self.slz=v self.minv=self.maxv=v self.sumv=v*(r-l+1) elif func=='mul': if self.slz: self.slz*=v self.minv=self.maxv=self.slz self.sumv=self.slz*(r-l+1) else: self.mlz*=v self.plz*=v t1,t2=self.minv*v,self.maxv*v self.minv,self.maxv=min(t1,t2),max(t1,t2) self.sumv*=v else:#'plus' if self.slz: self.slz+=v self.minv=self.maxv=self.slz self.sumv=self.slz*(r-l+1) else: self.plz+=v self.minv,self.maxv=self.minv+v,self.maxv+v self.sumv+=v*(r-l+1) class Segment_tree(object): ''' lazy标记，代表左右子树没有进行修改，该节点存储值是对的 ''' def __init__(self,maxn): self.St=[Node() for i in range(4*maxn+5)] self.l=0 self.r=0 def maintain(self,root): ''' maintain的时候保证左右子树的存储值都是对的 ''' self.St[root].minv=min(self.St[root*2].minv,self.St[root*2+1].minv) self.St[root].maxv=max(self.St[root*2].maxv,self.St[root*2+1].maxv) self.St[root].sumv=self.St[root*2].sumv+self.St[root*2+1].sumv def build_St(self,A,l,r,root): ''' 开始时： l=0,r=len(A)-1,root=1 ''' def build(root,l,r): if l==r: self.St[root].minv=A[l] self.St[root].maxv=A[l] self.St[root].sumv=A[l] return mid=(l+r)//2 build(root*2,l,mid) build(root*2+1,mid+1,r) self.maintain(root) root,l,self.r=1,0,len(A)-1 build(root,l,self.r) def pushdown(self,root,l,mid,r): if self.St[root].slz: self.St[root*2].add_lazy('set',self.St[root].slz,l,mid) self.St[root*2+1].add_lazy('set',self.St[root].slz,mid+1,r) else: self.St[root*2].add_lazy('mul',self.St[root].mlz,l,mid) self.St[root*2+1].add_lazy('mul',self.St[root].mlz,mid+1,r) self.St[root*2].add_lazy('plus',self.St[root].plz,l,mid) self.St[root*2+1].add_lazy('plus',self.St[root].plz,mid+1,r) self.St[root].slz=None self.St[root].plz=0 self.St[root].mlz=1 def update_func(self,ul,ur,func,v=0): ''' func:'add'、'mul'、'plus' ''' def update(root,l,r): mid=(l+r)//2 if ul&lt;=l and ur&gt;=r:#ul l r ur self.St[root].add_lazy(func,v,l,r) return self.pushdown(root,l,mid,r) if ul&lt;=mid: update(root*2,l,mid) if ur&gt;mid: update(root*2+1,mid+1,r) self.maintain(root) update(1,0,self.r) def query_func(self,ql,qr): def query(root,l,r): _min,_max,_sum=float('inf'),float('-inf'),0 mid=(l+r)//2 if ql&lt;=l and qr&gt;=r:#ql l r qr return self.St[root].minv,self.St[root].maxv,self.St[root].sumv self.pushdown(root,l,mid,r) if ql&lt;=mid:#左节点有 t=query(root*2,l,mid) _min=min(_min,t[0]) _max=max(_max,t[1]) _sum+=t[2] if qr&gt;mid:#右节点有 t=query(root*2+1,mid+1,r) _min=min(_min,t[0]) _max=max(_max,t[1]) _sum+=t[2] return _min,_max,_sum return query(1,0,self.r)","link":"/2020/03/10/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF/"},{"title":"Leetcode 7. 整数反转","text":"比较简单的一道题 题目内容 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 示例 1: 输入: 123输出: 321 示例 2: 输入: -123输出: -321示例 3: 输入: 120输出: 21注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 题解class Solution: def reverse(self, x: int) -&gt; int: if x&gt;=0: x= int(str(x)[::-1]) else: x= -int(str(-x)[::-1]) return x if x&gt;=-pow(2,31) and x&lt;=pow(2,31)-1 else 0","link":"/2020/03/05/Leetcode%207.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"},{"title":"正则表达式入门","text":"下午看了正则表达式必知必会，总结一波 注意，正则匹配机制是匹配到一串字符后，从匹配字符结尾的下一个位置，继续匹配 字符匹配层次单字符: ‘.’：匹配任意字符‘\\‘:转义元字符【’.’在”[]”内可以不进行转义】 多字符和的元字符:[]、’^’ “[abcd]”:abcd中的一个“[a-z]”:a到z中的一个“[^1-9]”:除了1到9，其他字符都可以 重复:”{}”、’+’、’*’、’?’k次重复上一个字符 ‘*’:[0,$\\infty$)‘+’:[1,$\\infty$)‘?’:{0,1}‘{a,b}:[a,b]‘{a}’:{a}‘{a,}:[a,$\\infty$) 以上都为贪婪型，即尽可能多的匹配，加上?变为懒惰型，如’*?’、’+?’、’{n,}?’不过，在线的正则表达式网站，加上?后只有第一个为懒惰，后面仍为贪婪型 特殊字符空白元字符 \\f:换页\\n:换行\\r:回车\\t:制表\\v:垂直制表 字母数字相关 \\d:[0-9]\\D:[^0-9]\\w:[a-zA-Z0-9_]\\W:[^a-zA-Z0-9_]\\s:[\\f\\n\\r\\t\\v]任一空白字符\\S:[^\\f\\n\\r\\t\\v] POSIX字符类 [:blank:]:[\\t ][:cntrl:]:ASCII控制字符，ASCII0-31、ASCII127[:digit:]:[0-9][:print:]:任一个可打印字符[:graph:]:[:print:]不包括空格[:lower:]:[a-z][:upper:]:[A-Z][:punct:]:既不属于:alnum:也不属于[:cntrl:][:space:]:[\\f\\n\\r\\t\\v][:xdigit:]:[a-fA-F0-9] 使用:[[:digit:]]双括号表示 位置匹配 \\b:单词开始或结尾\\B:不匹配单词边界^:字符串开始边界，在[]中代表的是取反$:字符串结束边界(^m):放在开头表示字符串行分隔符作为字符串边界对待\\A:字符串开始，不随(^m)改变行为，但又有些不支持\\Z:字符串结尾，不随(^m)改变行为，但又有些不支持 表达式和替换子表达式:’|’、”()”通过”()”把子串作为一个整体,比如(&nbsp;){2}代表&nbsp;&nbsp;子表达式嵌套：((x)|(y)):(x)或者(y) 回溯引用：前后一致匹配:”\\k”“(x).*\\1” : \\1代表的就是(x)【\\k代表的是第k个子表达式】 表达式在替换中的应用:’$’find:(\\w+[\\w\\.]*@[\\w\\.]+\\.\\w+)【邮箱地址】 replace: &lt;A HREF=&quot;mailto:$1&quot;&gt;$1&lt;/A&gt;【跨模式使用】 替换中大小写转换 \\E:结束\\L或\\U转换\\l:下一个转为小写\\L:\\L到\\E转为小写\\u:下一个转为大写\\U:\\U到\\E转为大写 前后查找查找到的字符串的一部分http://www.forta.com/前向查找”(?=)”–&gt;”.+(?=:)”–&gt;搜索到的是http【后接串匹配】 (?=) 正向前查找(?!) 负向前查找【后接串不匹配的子串】(?&lt;!) 正向后查找(?&lt;!) 负向后查找【前接串不匹配的子串】 嵌入条件: (?(condition)true-regex|false-regex)condition存在的时候，为true-regex否则false-regex，其中|false-regex可以省略 condition:回溯引用条件【根据子表达式来if】&quot;(x).\\*(?(1)x|y)&quot; 如果(x)存在：&quot;(x).\\*x&quot;不存在&quot;(x).\\*y&quot; condition:前后查找条件【根据前后串的情况来进行if】对于5数字和5数子-4数字两种情况【14789-1589、15979】\\d{5}(?(?=-)-\\d{4})","link":"/2020/03/03/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"Leetcode 8. 字符串转换整数 (atoi)","text":"按题目逻辑写代码即可 题目内容 请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 示例 1:输入: “42”输出: 42示例 2:输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3: 输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。示例 4: 输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 题解class Solution: def myAtoi(self, str: str) -&gt; int: str=str.strip() if len(str)==0: return 0 sign=1 if str[0]=='-' or str[0]=='+': sign=-1 if str[0]=='-' else 1 str=str[1:] i=0 while i&lt;len(str): if str[i]&lt;'0' or str[i]&gt;'9': break i+=1 INT_MAX,INT_MIN=2**31-1,-2**31 if i==0: return 0 ans=sign*int(str[:i]) if ans&gt;INT_MAX: ans=INT_MAX if ans&lt;INT_MIN: ans=INT_MIN return ans","link":"/2020/03/05/Leetcode%208.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/"},{"title":"UVA 210. Concurrency Simulator | 紫书6-1","text":"逻辑其实挺清晰的，但是数据坑点很多,怀疑数据中可能有多的空行。 题目链接https://vjudge.net/problem/UVA-210 import sys import queue def _input(): lines=sys.stdin.readlines() for val in lines: x=val.strip() if x!='': yield x c=_input() def func(): n,t1,t2,t3,t4,t5,Q=list(map(int,next(c).split())) code_list=[] for i in range(n): que=queue.deque() while 1: s=next(c).strip() que.append(s) if s=='end': break code_list.append(que) block_que=queue.deque() wait_que=queue.deque() locked=0 var2val={} for i in range(n): wait_que.append(i) while len(wait_que)!=0: k=wait_que.popleft() t=Q while 1: s=code_list[k].popleft() if s=='end': break elif s=='lock': t-=t3 if locked==1: code_list[k].appendleft(s) block_que.append(k) break else: locked=1 elif s=='unlock': t-=t4 locked=0 if len(block_que)&gt;0: wait_que.appendleft(block_que.popleft()) elif '=' in s: t-=t1 var2val[s[0]]=s.split('=')[-1].strip() else: t-=t2 var=s[-1] print(f'{k+1}: {var2val.get(var,0)}') if t&lt;=0: wait_que.append(k) break T=int(next(c)) for i in range(T): if i&gt;0: print() func()","link":"/2020/03/02/UVA%20210.%20Concurrency%20Simulator/"}],"tags":[{"name":"uva","slug":"uva","link":"/tags/uva/"},{"name":"白书","slug":"白书","link":"/tags/%E7%99%BD%E4%B9%A6/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"kmp","slug":"kmp","link":"/tags/kmp/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"特殊结构","slug":"特殊结构","link":"/tags/%E7%89%B9%E6%AE%8A%E7%BB%93%E6%9E%84/"},{"name":"紫书","slug":"紫书","link":"/tags/%E7%B4%AB%E4%B9%A6/"},{"name":"RMQ","slug":"RMQ","link":"/tags/RMQ/"},{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"}],"categories":[{"name":"oj","slug":"oj","link":"/categories/oj/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"}]}